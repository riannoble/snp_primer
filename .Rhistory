start_distance,
end_distance,
center,
far,
shift)
df
print("R get filter activated")
# Applied filters before multiplexing
df <- stage1_filter(df, desired_tm, diff, Homodimer, hairpin)
df
df
# This is the soft filter. We first make sure there is left after after the filtering. If not, we keep the best option
for (i in 1:length(df[[3]])){
# Homodimer
k = df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_homodimer)[2,]) < Homodimer]
if (length(k) > 5) {
df[[3]][[i]] <- df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_homodimer)[3,]) < Homodimer]
}else{
print(paste("Homodimer - Bottle neck", df[[1]][[i]]))
calculated_values <- sapply(df[[3]][[i]], calculate_homodimer)
differences <- abs(unlist(calculated_values[2,]) - Homodimer)
min_diff_indices <- order(differences)[1:min(5, length(differences))]
df[[3]][[i]] <- df[[3]][[i]][min_diff_indices]
}
# Hairpin
k = df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_hairpin)[2,]) < hairpin]
if (length(k) > 5) {
df[[3]][[i]] <- df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_hairpin)[2,]) < hairpin]
}else{
print(paste("Hairpin - Bottle neck", df[[1]][[i]]))
calculated_values <- sapply(df[[3]][[i]], calculate_hairpin)
differences <- abs(unlist(calculated_values[2,]) - hairpin)
min_diff_indices <- order(differences)[1:min(5, length(differences))]
df[[3]][[i]] <- df[[3]][[i]][min_diff_indices]
}
# Filter Tm above target
k = df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_tm)) < desired_tm + diff]
if (length(k) > 5) {
df[[3]][[i]] <- k
}else{
print(paste("Tm_above - Bottle neck", df[[1]][[i]]))
calculated_values <- sapply(df[[3]][[i]], calculate_tm)
differences <- abs(unlist(calculated_values) - (desired_tm + diff) )
min_diff_indices <- order(differences)[1:min(5, length(differences))]
df[[3]][[i]] <- df[[3]][[i]][min_diff_indices]
}
# df[[2]][[i]] <- df[[2]][[i]][unlist(sapply(df[[2]][[i]], calculate_tm)) > desired_tm - diff]
# Filter Tm below target
k = df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_tm)) > desired_tm - diff]
if (length(k) > 5) {
df[[3]][[i]] <- k
} else {
print(paste("TM below - Bottle neck", df[[1]][[i]]))
calculated_values <- sapply(df[[3]][[i]], calculate_tm)
differences <- abs(unlist(calculated_values) - (desired_tm - diff) )
min_diff_indices <- order(differences)[1:min(5, length(differences))]
df[[3]][[i]] <- df[[3]][[i]][min_diff_indices]
}
}
df
for (i in 1:length(df[[4]])){
if (length(df[[4]][[i]]) != 0){
df[[4]][[i]] <- df[[4]][[i]][unlist(sapply(df[[4]][[i]], calculate_tm)) > desired_tm - diff]
df[[4]][[i]] <- df[[4]][[i]][unlist(sapply(df[[4]][[i]], calculate_hairpin)[2,]) < hairpin]
} else {}
}
df[[4]][[i]] <- df[[4]][[i]][unlist(sapply(df[[4]][[i]], calculate_tm)) > desired_tm - diff]
df[[4]][[i]] <- df[[4]][[i]][unlist(sapply(df[[4]][[i]], calculate_hairpin)[2,]) < hairpin]
df[[4]][[i]] <- df[[4]][[i]][unlist(sapply(df[[4]][[i]], calculate_hairpin)[2,]) > hairpin]
View(df)
View(df[[3]][[1]])
primer = "rs9462492, rs58318008, rs1421085, rs9939609, rs1121980"
shift = 100
desired_tm = 64
diff = 3
Heterodimer_tm = 50
Homodimer <- 45
top <- 2
hairpin <- 45
# Explore options 800 bp away from the SNP location upstream and downstream
center <- 800
hairpin <- 45
# Search the range from 600 to 1,000. (800+200 and 800-200)
far <- 200
start_distance <- 15
end_distance <- 28
# Accessing database
print("Execute MART API")
snp_list <- strsplit(primer, " ")[[1]]
upStream <- center
downStream <- center
# Accessing database
print("Execute MART API")
snp_list <- strsplit(primer, " ")[[1]]
print("snp_list generated")
upStream <- center
print("upstream")
downStream <- center
print("downstream")
snpmart <- useMart("ENSEMBL_MART_SNP", dataset = "hsapiens_snp") # possibly establish earlier?
snp_sequence <- getBM(attributes = c('refsnp_id', 'snp'),
filters = c('snp_filter', 'upstream_flank', 'downstream_flank'),
checkFilters = FALSE,
values = list(snp_list, upStream, downStream),
mart = snpmart,
bmHeader = TRUE)
snp_sequence
#Create a new data frame
snp_wrangled <- data.frame(matrix(ncol = 2, nrow = 0))
# New dataframe contains all snp variation sequences plus a snp id column
for (j in snp_sequence$`Variant name`){
for (i in list_seq(snp_sequence$`Variant sequences`[snp_sequence$`Variant name`==j])){
snp_wrangled[nrow(snp_wrangled) + 1,] <- c(j, i)
}
}
# Rename columns and data frame
colnames(snp_wrangled) = c("snpID", "sequence")
# New dataframe contains all snp variation sequences plus a snp id column
snp_wrangled <- mutate(snp_wrangled, snp_character = substr(snp_wrangled$sequence, 801, 801)) # 804 is the universal snp position for all snps bc of seq setup
# I have a long long string. I want to get the left 18~25 characters and
# between 300 ~ 800 units away, I want another 18 ~ 25
df <- all_text_wrangling(snp_wrangled,
start_distance,
end_distance,
center,
far,
shift)
df
View(df)
View(df[[3]][[1]])
View(df[[4]][[1]])
df
# This is the soft filter. We first make sure there is left after after the filtering. If not, we keep the best option
for (i in 1:length(df[[3]])){
# Homodimer
k = df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_homodimer)[2,]) < Homodimer]
if (length(k) > 5) {
df[[3]][[i]] <- df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_homodimer)[3,]) < Homodimer]
}else{
print(paste("Homodimer - Bottle neck", df[[1]][[i]]))
calculated_values <- sapply(df[[3]][[i]], calculate_homodimer)
differences <- abs(unlist(calculated_values[2,]) - Homodimer)
min_diff_indices <- order(differences)[1:min(5, length(differences))]
df[[3]][[i]] <- df[[3]][[i]][min_diff_indices]
}
# Hairpin
k = df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_hairpin)[2,]) < hairpin]
if (length(k) > 5) {
df[[3]][[i]] <- df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_hairpin)[2,]) < hairpin]
}else{
print(paste("Hairpin - Bottle neck", df[[1]][[i]]))
calculated_values <- sapply(df[[3]][[i]], calculate_hairpin)
differences <- abs(unlist(calculated_values[2,]) - hairpin)
min_diff_indices <- order(differences)[1:min(5, length(differences))]
df[[3]][[i]] <- df[[3]][[i]][min_diff_indices]
}
# Filter Tm above target
k = df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_tm)) < desired_tm + diff]
if (length(k) > 5) {
df[[3]][[i]] <- k
}else{
print(paste("Tm_above - Bottle neck", df[[1]][[i]]))
calculated_values <- sapply(df[[3]][[i]], calculate_tm)
differences <- abs(unlist(calculated_values) - (desired_tm + diff) )
min_diff_indices <- order(differences)[1:min(5, length(differences))]
df[[3]][[i]] <- df[[3]][[i]][min_diff_indices]
}
# df[[2]][[i]] <- df[[2]][[i]][unlist(sapply(df[[2]][[i]], calculate_tm)) > desired_tm - diff]
# Filter Tm below target
k = df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_tm)) > desired_tm - diff]
if (length(k) > 5) {
df[[3]][[i]] <- k
} else {
print(paste("TM below - Bottle neck", df[[1]][[i]]))
calculated_values <- sapply(df[[3]][[i]], calculate_tm)
differences <- abs(unlist(calculated_values) - (desired_tm - diff) )
min_diff_indices <- order(differences)[1:min(5, length(differences))]
df[[3]][[i]] <- df[[3]][[i]][min_diff_indices]
}
}
df
df[[4]][[7]]
sapply(df[[4]][[7]], calculate_hairpin)[2,])
sapply(df[[4]][[7]], calculate_hairpin)[2,]
unlist(sapply(df[[4]][[7]], calculate_hairpin)[2,])
df[[4]][[7]][unlist(sapply(df[[4]][[7]], calculate_hairpin)[2,]) < hairpin]
df[[4]][[7]] <- df[[4]][[7]][unlist(sapply(df[[4]][[7]], calculate_tm)) > desired_tm - diff]
df[[4]][[7]] <- df[[4]][[7]][unlist(sapply(df[[4]][[7]], calculate_hairpin)[2,]) < hairpin]
df[[4]][[7]]
for (i in 1:length(df[[4]])){
if (length(df[[4]][[i]]) != 0){
df[[4]][[i]] <- df[[4]][[i]][unlist(sapply(df[[4]][[i]], calculate_tm)) > desired_tm - diff]
}
if (length(df[[4]][[i]]) != 0){
df[[4]][[i]] <- df[[4]][[i]][unlist(sapply(df[[4]][[i]], calculate_hairpin)[2,]) < hairpin]
}
}
df
for (i in 1:length(df[[4]])){
if (length(df[[4]][[i]]) != 0){
df[[4]][[i]] <- df[[4]][[i]][unlist(sapply(df[[4]][[i]], calculate_homodimer)[2,]) < Homodimer]
df[[4]][[i]] <- df[[4]][[i]][unlist(sapply(df[[4]][[i]], calculate_tm)) < desired_tm + diff]
} else {}
}
df
for (i in length(df[[1]]):1){
if (length(df[[4]][[i]]) == 0){
df <- df[-i, ]
}
}
df
primer = "rs9462492, rs58318008, rs1421085, rs9939609, rs1121980"
shift = 100
desired_tm = 64
diff = 3
Heterodimer_tm = 50
Homodimer <- 45
top <- 2
hairpin <- 45
# Explore options 800 bp away from the SNP location upstream and downstream
center <- 800
hairpin <- 45
# Search the range from 600 to 1,000. (800+200 and 800-200)
far <- 200
start_distance <- 15
end_distance <- 28
# Accessing database
print("Execute MART API")
snp_list <- strsplit(primer, " ")[[1]]
upStream <- center
downStream <- center
# Accessing database
print("Execute MART API")
snp_list <- strsplit(primer, " ")[[1]]
print("snp_list generated")
upStream <- center
print("upstream")
downStream <- center
print("downstream")
snpmart <- useMart("ENSEMBL_MART_SNP", dataset = "hsapiens_snp") # possibly establish earlier?
snpmart <- useMart("ENSEMBL_MART_SNP", dataset = "hsapiens_snp") # possibly establish earlier?
snp_sequence <- getBM(attributes = c('refsnp_id', 'snp'),
filters = c('snp_filter', 'upstream_flank', 'downstream_flank'),
checkFilters = FALSE,
values = list(snp_list, upStream, downStream),
mart = snpmart,
bmHeader = TRUE)
#Create a new data frame
snp_wrangled <- data.frame(matrix(ncol = 2, nrow = 0))
# New dataframe contains all snp variation sequences plus a snp id column
for (j in snp_sequence$`Variant name`){
for (i in list_seq(snp_sequence$`Variant sequences`[snp_sequence$`Variant name`==j])){
snp_wrangled[nrow(snp_wrangled) + 1,] <- c(j, i)
}
}
# Rename columns and data frame
colnames(snp_wrangled) = c("snpID", "sequence")
# New dataframe contains all snp variation sequences plus a snp id column
snp_wrangled <- mutate(snp_wrangled, snp_character = substr(snp_wrangled$sequence, 801, 801)) # 804 is the universal snp position for all snps bc of seq setup
# I have a long long string. I want to get the left 18~25 characters and
# between 300 ~ 800 units away, I want another 18 ~ 25
df <- all_text_wrangling(snp_wrangled,
start_distance,
end_distance,
center,
far,
shift)
df
print("Primer generated")
print("R get filter activated")
# Applied filters before multiplexing
df <- stage1_filter(df, desired_tm, diff, Homodimer, hairpin)
# Apply all the filters before multiplexing
stage1_filter <- function(df,
desired_tm,
diff,
Homodimer,
hairpin){
df
# This is the soft filter. We first make sure there is left after after the filtering. If not, we keep the best option
for (i in 1:length(df[[3]])){
# Homodimer
k = df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_homodimer)[2,]) < Homodimer]
if (length(k) > 5) {
df[[3]][[i]] <- df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_homodimer)[3,]) < Homodimer]
}else{
print(paste("Homodimer - Bottle neck", df[[1]][[i]]))
calculated_values <- sapply(df[[3]][[i]], calculate_homodimer)
differences <- abs(unlist(calculated_values[2,]) - Homodimer)
min_diff_indices <- order(differences)[1:min(5, length(differences))]
df[[3]][[i]] <- df[[3]][[i]][min_diff_indices]
}
# Hairpin
k = df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_hairpin)[2,]) < hairpin]
if (length(k) > 5) {
df[[3]][[i]] <- df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_hairpin)[2,]) < hairpin]
}else{
print(paste("Hairpin - Bottle neck", df[[1]][[i]]))
calculated_values <- sapply(df[[3]][[i]], calculate_hairpin)
differences <- abs(unlist(calculated_values[2,]) - hairpin)
min_diff_indices <- order(differences)[1:min(5, length(differences))]
df[[3]][[i]] <- df[[3]][[i]][min_diff_indices]
}
# Filter Tm above target
k = df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_tm)) < desired_tm + diff]
if (length(k) > 5) {
df[[3]][[i]] <- k
}else{
print(paste("Tm_above - Bottle neck", df[[1]][[i]]))
calculated_values <- sapply(df[[3]][[i]], calculate_tm)
differences <- abs(unlist(calculated_values) - (desired_tm + diff) )
min_diff_indices <- order(differences)[1:min(5, length(differences))]
df[[3]][[i]] <- df[[3]][[i]][min_diff_indices]
}
# df[[2]][[i]] <- df[[2]][[i]][unlist(sapply(df[[2]][[i]], calculate_tm)) > desired_tm - diff]
# Filter Tm below target
k = df[[3]][[i]][unlist(sapply(df[[3]][[i]], calculate_tm)) > desired_tm - diff]
if (length(k) > 5) {
df[[3]][[i]] <- k
} else {
print(paste("TM below - Bottle neck", df[[1]][[i]]))
calculated_values <- sapply(df[[3]][[i]], calculate_tm)
differences <- abs(unlist(calculated_values) - (desired_tm - diff) )
min_diff_indices <- order(differences)[1:min(5, length(differences))]
df[[3]][[i]] <- df[[3]][[i]][min_diff_indices]
}
}
df
for (i in 1:length(df[[4]])){
if (length(df[[4]][[i]]) != 0){
df[[4]][[i]] <- df[[4]][[i]][unlist(sapply(df[[4]][[i]], calculate_tm)) > desired_tm - diff]
}
if (length(df[[4]][[i]]) != 0){
df[[4]][[i]] <- df[[4]][[i]][unlist(sapply(df[[4]][[i]], calculate_hairpin)[2,]) < hairpin]
}
}
df
for (i in 1:length(df[[4]])){
if (length(df[[4]][[i]]) != 0){
df[[4]][[i]] <- df[[4]][[i]][unlist(sapply(df[[4]][[i]], calculate_homodimer)[2,]) < Homodimer]
df[[4]][[i]] <- df[[4]][[i]][unlist(sapply(df[[4]][[i]], calculate_tm)) < desired_tm + diff]
} else {}
}
df
for (i in length(df[[1]]):1){
if (length(df[[4]][[i]]) == 0){
df <- df[-i, ]
}
}
df
return(df)
}
primer = "rs9462492, rs58318008, rs1421085, rs9939609, rs1121980"
shift = 100
desired_tm = 64
diff = 3
Heterodimer_tm = 50
Homodimer <- 45
top <- 2
hairpin <- 45
# Explore options 800 bp away from the SNP location upstream and downstream
center <- 800
hairpin <- 45
# Search the range from 600 to 1,000. (800+200 and 800-200)
far <- 200
start_distance <- 15
end_distance <- 28
# Accessing database
print("Execute MART API")
snp_list <- strsplit(primer, " ")[[1]]
upStream <- center
downStream <- center
# Accessing database
print("Execute MART API")
snp_list <- strsplit(primer, " ")[[1]]
print("snp_list generated")
upStream <- center
print("upstream")
downStream <- center
print("downstream")
snpmart <- useMart("ENSEMBL_MART_SNP", dataset = "hsapiens_snp") # possibly establish earlier?
snp_sequence <- getBM(attributes = c('refsnp_id', 'snp'),
filters = c('snp_filter', 'upstream_flank', 'downstream_flank'),
checkFilters = FALSE,
values = list(snp_list, upStream, downStream),
mart = snpmart,
bmHeader = TRUE)
#Create a new data frame
snp_wrangled <- data.frame(matrix(ncol = 2, nrow = 0))
# New dataframe contains all snp variation sequences plus a snp id column
for (j in snp_sequence$`Variant name`){
for (i in list_seq(snp_sequence$`Variant sequences`[snp_sequence$`Variant name`==j])){
snp_wrangled[nrow(snp_wrangled) + 1,] <- c(j, i)
}
}
# Rename columns and data frame
colnames(snp_wrangled) = c("snpID", "sequence")
# New dataframe contains all snp variation sequences plus a snp id column
snp_wrangled <- mutate(snp_wrangled, snp_character = substr(snp_wrangled$sequence, 801, 801)) # 804 is the universal snp position for all snps bc of seq setup
# I have a long long string. I want to get the left 18~25 characters and
# between 300 ~ 800 units away, I want another 18 ~ 25
df <- all_text_wrangling(snp_wrangled,
start_distance,
end_distance,
center,
far,
shift)
df
print("R get filter activated")
# Applied filters before multiplexing
df <- stage1_filter(df, desired_tm, diff, Homodimer, hairpin)
print(df)
View(df)
print(df)
print("Filtered")
# Count how many candidates there are for each primer group
df <- df %>%
mutate(substrings_count = lengths(substrings),
faraway_count = lengths(faraway)) %>%
relocate(snpID, substrings_count, faraway_count, everything()) # Moves a block of columns
# Display the updated nested tibble
return(df)
df
print("Tree search") # relationship measure?
df
df
# Keep only certain amount of candidates
df[[5]] <- extract_top_n(df[[5]], 2) # narrow down substrings column to 5?
df[[6]] <- extract_top_n(df[[6]], 2) # narrow down faraway column to 5?
# Technical debt
df_rm <- df[!duplicated(df$snpID), ] # ? eliminates all RIGHT direction
df_rm
# Technical debt
df_rm <- df[!duplicated(df$snpID, df$snp_character), ] # ? eliminates all RIGHT direction
df_rm
# Technical debt
df_rm <- df[!duplicated(c(df$snpID, df$snp_character)), ] # ? eliminates all RIGHT direction
df_rm <- df %>%
group_by(snpID) %>%
filter(substrings_count == max(substrings_count))
df_rm
print(df_rm)
level5 <- soulofmultiplex(df_rm, Heterodimer_tm) # ? stops running
list_3 <- list()
for (i in 1:length(df[[1]])){
list_3 <- c(list_3,
list(unlist(df[[5]][[i]])),
list(unlist(df[[6]][[i]])))
}
list_3
View(df)
View(df[[5]][[1]])
View(df[[5]][[1]])
View(df[[6]][[1]])
# Arrange the list from small to big
arranged_list <- list_3
# Prepare the initial list for multiplexing
level2 <- list()
level3 <- list()
level4 <- list()
level2 <- incoming_list(arranged_list[[1]])
View(arranged_list)
View(level2)
level3 <- replace_end_nodes(incoming_list(arranged_list[[1]]),
incoming_list(arranged_list[[2]])
)
level3
if (length(arranged_list) != 2) {
level3 <- replace_end_nodes(level3,
incoming_list(arranged_list[[3]])
)
str(level3)
# arranged_list
# Running
print(length(arranged_list))
for (i in 4:length(arranged_list)){
# Start a timer
start_time <- Sys.time()
# Get all the end points from the tree
endpoints <- get_endpoints(level3)
# Endpoints come back a little messy
endpoints <- clean_endpoints(endpoints)
print(paste("Start with ", length(endpoints)))
# Evaluate all the ned points to its parents
bad_nodes <- compute_bad_nodes(endpoints, Heterodimer_tm) # go back to compute_bad_nodes
print(paste("We are removing: ", length(bad_nodes))) # why aren't we removing anything?
# to debug, add print statements throughout the for loop for more accurate location of bug
# Remove bad nodes if there are any
if (length(bad_nodes) != 0){
level3 <- Iterate_remove(level3, bad_nodes)
level3 <- remove_empty_lists(level3)
}
# If all nodes are bad, return NULL
if (length(endpoints) == length(bad_nodes)){
print("All nodes are removed during the process")
return(NULL)
}
print(paste("After trimming: ", length(get_endpoints(level3))))
# Stop adding list if we are at the last level
if (1){
level4 <- incoming_list(arranged_list[[i]])
print(paste("New list: ", length(level4)))
level3 <- replace_end_nodes(level3, level4)
print(paste("level3 + level4: ", length(get_endpoints(level3))))
}
# Summarize results for this level
print(paste("How far are we: ", i))
print(paste("Time" , round(Sys.time() - start_time, 1)))
print("--------------------------")
}
}
level3
